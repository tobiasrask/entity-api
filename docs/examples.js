/**
 * We suggest that you organize your code base using entities, for example something like this:
 * 
 * src/entities/message/
 * src/entities/message/message.js (Entity)
 * src/entities/message/message-type.js (Entity type)
 * src/entities/message/message-access.js (Access handler)
 * src/entities/message/message-storage.js (Storage handler)
 * src/entities/message/message-view.js (View handler)
 * src/entities/message/message-list.js (List handler)
 *
 */

import {
  Entity,
  EntityAPI,
  EntityType,
  EntityStorageHandler,
  ConfigStorageBackend,
  EntityViewHandler,
  fieldAPI
} from 'entity-api'

// Define custom Entity called 'message'.
class MessageEntity extends Entity {

  create(_variables = {}, callback) {

    // Set created time for message
    this.set('created', Date.now())

    callback(null)
  }
 
  /**
   * Impementation of hook getFieldDefinitions().
   *
   * Here we define fields for this message entity.
   * 
   * - Message id is protected value
   * - Message contains some body text
   * - Created time for message is protected and automatically assigned
   * 
   * We also have two view modes called 'full' and 'list'.
   * 
   * - Note that all fields are rendered for 'full' view mode
   * - Only id and created time are rendered for 'list' view mode
   */
  static getFieldDefinitions() {
    const fields = new Map()
    fields.set('id', fieldAPI.createBasefield('text')
      .setName('ID')
      .setDescription('Entity identifier')
      .setProtected(true)
      .setProperty('view_properties', {
        full: { view_field: true },
        list: { view_field: true }
      }))
    fields.set('body', fieldAPI.createBasefield('text')
      .setName('Message')
      .setDescription('Message body')
      .setProperty('view_properties', {
        full: { view_field: true }
      }))
    fields.set('created', fieldAPI.createBasefield('integer')
      .setName('Created time')
      .setDescription('Created time for message')
      .setProtected(true)
      .setProperty('view_properties', {
        full: { view_field: true },
        list: { view_field: true }
      }))
    return fields
  }

  /**
  * Define entity indexes.
  * 
  * - Entity 'id' is primary key for message.
  * - We also enable autogenerated uuid values for our hash key.
  */
  static getFieldIndexDefinitions() {
    return [
      { 'fieldName': 'id', 'indexType': 'HASH', 'auto': true }
    ]
  }

  /**
   * Implement custom method 'explain' for this entity. It will return short
   * description about this message.
   */
  explain() {
    return `This message says: "${this.get('body')}"`
  }
}

// Define custom storage handler for message by extending EntityStorageHandler
class MessageStorageHandler extends EntityStorageHandler {
  constructor(variables = {}) {
    // Define storage backend for this entity type.
    // ConfigStorageBackend is in-memory storage implemented with this module. 
    // See other storage backends, like Dynamodb and Elasticsearch storage
    // backends for persistent storage.
    variables.storageBackend = ConfigStorageBackend
    super(variables)
  }
}

// Define custom view handler for message by extending EntityViewHandler
// This allows you to perform custom logic when calling entity.view() method.
class MessageViewHandler extends EntityViewHandler {

}

// Define entity type and how it should be stored, viewed, accessed etc
class MessageEntityType extends EntityType {

  // In constructor we define 
  constructor(variables = {}) {

    // Entity type id for this entity
    variables.entityTypeId = 'message'

    // Entity class for entity
    variables.entityClass = MessageEntity

    variables.handlers = {
      storage: new MessageStorageHandler(),
      view: new MessageViewHandler(variables),
    }
    super(variables)
  }
}


// Register entity type. After this you can refer this entity throuhg Entity API
const entityAPI = EntityAPI.getInstance({}, true)
entityAPI.registerEntityType(new MessageEntityType())


// Now you can create new instance of message entity with provided data
const data = {
  body: 'Hi there'
}

entityAPI.getStorage('message').create(data)
  .then((entity) => {
    // Entity is an instance of our MessageEntity class.
    // You can access instance methods here, let's call our custom method explain()
    console.log(entity.explain())
    // --> This message says: "Hi there"

    // Now we create full view from message by calling method entity.view().
    // View mode is 
    return entity.view({ viewMode: 'full' })
  })
  .then((viewedEntity) => {
    // Viewed entity is DTO (Data Transfer Object) generated from entity fields.
    console.log(viewedEntity)
    // --> {id: '00112233-4455-6677-8899-aabbccddeeff', body': 'Hi there', created: 1234567890 }
  })


// Storing and saving entities. See full list of Entity API methods
entityAPI.getStorage('message').createAndSave(data)
  .then((entity) => {

    console.log(`Message ${entity.id()} now created and stored to storage backend.`)

    return entityAPI.getStorage('message').load(entity.id())
  })
  .then((entity) => {

    console.log(`Message ${entity.id()} is now loaded from storage backend.`)

    // Update message body and store changes
    entity.set('body', 'Updated body text')
    return entity.save()
  })


// Error handling
entityAPI.getStorage('message').create(data)
  .then((entity) => {
    if (!entity) {
      throw new Error('Unable to create entity')
    }
  })
  .catch((err) => {
    // If there was an error when creating entity, 
    console.error(err)
  })
